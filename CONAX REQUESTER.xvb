'
'Cerebro Card ATR Restorer v1
'By 007.4
'
'This can be used to restore the ATR of a Cerebro card that just shows "3B" or no ATR.
'Run the script and at the same time rapidly pull and replace the card from the reader
'until you see a response such as "3B......".
'Then press the "Analyse ATR" button to see the ATR.
Option Explicit

call Settings()

Sub Main()
call SendApp()
End Sub

Function SendApp()
Dim RetValue
Dim ErrorString
Dim LN
Dim ReturnByte
Dim Dumpstring
dim INS,i,p2


'Trap the card
' For INS = 1 to 5 step 1


sc.reset
sc.delay(ins)

sc.write("DD 26 00 00 03 69 01 00")
sc.read(2)

sc.write("DD 26 00 00 03 10 01 40")
sc.read(2)

sc.write("dd ca 00 00 11")
sc.read(&h14)

sc.write("DD 82 00 00 11 11 0F 01 B0 0F FF FF FB 00 00 09 04 0B 00 E0 30 2B")
sc.read(2)

sc.write("dd ca 00 00 1A")
sc.read(&h1A+3)

sc.write("DD C6 00 00 03 1C 01 00")
sc.read(2)

sc.write("dd ca 00 00 31")
sc.read(&h31+3)

sc.write("DD C6 00 00 03 1C 01 01")
sc.read(2)

sc.write("DD A2 00 00 3A 14 38 00 80 70 34 70 32 64 21 72 C1 BB EB 71 2C F9 3F B8 9D 14 B9 AA 9E 15 95 10 7B 83 63 22 00 6B C3 04 10 B7 70 AB DA 5D 44 DA 2F 2E 43 78 1C A2 A5 BA A5 FB 43 06 50 64 9C")
sc.delay(1000)
sc.read(2)

sc.write("dd ca 00 00 22")
sc.read(&h22+3)

End Function

Function HexToDec(HexNumber)
    ' This function takes a string as input, assuming it to be a Hexidecimal string,
    ' and converts it to a decimal number.
    HexNumber=Replace(UCase(HexNumber)," ","")
    HexToDec=CLng("&H"+HexNumber)
End Function

Function HexString(Number,Length)
    ' This function takes 2 arguments, a number and a length.  It converts the decimal
    ' number given by the first argument to a Hexidecimal string with its length
    ' equal to the number of digits given by the second argument
    Dim RetVal
    Dim CurLen
    RetVal=Hex(Number)
    CurLen=Len(RetVal)
    If CurLen<Length Then
        RetVal=String(Length-CurLen,"0") & RetVal
    End If
    HexString=RetVal
End Function




Sub Settings()
    Wx.BaudRate = 9600
    Wx.ResetBaudRate = 9600
    Wx.Parity = 2                    ' 0 = None, 1 = Odd, 2 = Even, 3 = Mark, 4 = Space
    Wx.StopBits = 2                  ' 0 = 1 stop bit, 1 = 1.5 stop bits, 2 = 2 stop bits
    Wx.DTRControl = 1                ' Initial state of DTR  0 = off, 1 = on
    Wx.RTSControl = 0                ' Initial state of RTS  0 = off, 1 = on
    Wx.ResetDelay = 1000             ' In microseconds
    Wx.ByteDelay = 500              ' In microseconds
    Wx.RxByteTimeout = 20           ' In milliseconds
    Wx.ResetMode = 1                 ' 0 = No Resets, 1 = ISO Reset (Expect a ATR), 2 = Device Reset (No ATR)
    Wx.ResetLine = 0                 ' 0 = Toggle RTS for Reset, 1 = Toggle DTR for Reset
    Wx.ByteConvention = 1            ' 0 = Inverse, 1 = Direct
    Wx.FlushEchoByte = 1             ' 0 = no flush, 1 = flush - A Phoenix interface will echo each byte transmitted.
    Wx.FlushBeforeWrite = 1          ' 0 = no flush, 1 = flush - Flush the receive buffer before each write to strip off Null bytes.
    Wx.IgnoreTimeouts = 1            ' 0 = Abort script on a receive timeout, 1 = Ignore all receive timeouts
    Wx.ResetAfterTimeout = 0         ' 0 = Don't reset after a timeout, 1 = do a reset after a timeout  - Not used if "IgnoreTimeouts=0"
    Wx.LogTransactions = 0           ' 0 = Don't log transactions, 1 = log transactions
    Wx.DisplayUSW = 0                ' Display USW after script complete 0 = no, 1 = yes
    Wx.DisplayFuse = 0               ' Display Fuse after script complete 0 = no, 1 = yes
End Sub
