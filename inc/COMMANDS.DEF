Rem BasicCard Sample Source Code
Rem ------------------------------------------------------------------
Rem Copyright (C) 1997-2001 ZeitControl GmbH
Rem You have a royalty-free right to use, modify, reproduce and 
Rem distribute the Sample Application Files (and/or any modified 
Rem version) in any way you find useful, provided that you agree 
Rem that ZeitControl GmbH has no warranty, obligations or liability
Rem for any Sample Application Files.
Rem ------------------------------------------------------------------

Rem Pre-defined BasicCard commands

#IfNotDef CommandsDefIncluded ' Prevent multiple inclusion
Const CommandsDefIncluded = True

#Include AlgID.DEF

Declare Command &HC0 &H00 GetState(Lc=0, State@, Version$)
Declare Command &HC0 &H02 EepromSize(Lc=0, Start%, Length%)
Declare Command &HC0 &H04 ClearEeprom(Length%, Disable Le)

Rem  Since Version 3.01, the WRITE EEPROM command is no longer supported.
Rem  Use it at your own risk!
Rem
Rem  Declare Command &HC0 &H06 WriteEeprom(Data$, Disable Le)

Declare Command &HC0 &H08 ReadEeprom(Lc=0, Data$)
Declare Command &HC0 &H0A EepromCRC(Length%)
Declare Command &HC0 &H0A EepromCRC32(Lc=2, CRCHi%, CRCLo%, Le=4)
Declare Command &HC0 &H0C SetState()
Declare Command &HC0 &H0E GetApplicationID(Lc=0, Name$)
Declare Command &HC0 &H10 StartEncryption(RA&, Le=0)
Declare Command &HC0 &H10 StartEncryptionWithKDP(RA&, ReadOnly KDP$, Le=0)
Declare Command &HC0 &H10 ProEncryption(RAHi&, RALo&, Le=0)
Declare Command &HC0 &H10 ProEncryptionWithKDP(RAHi&, RALo&, ReadOnly KDP$, Le=0)
Declare Command &HC0 &H10 SMEncryption(Algorithm@, RAHi&, RALo&, Le=0)
Declare Command &HC0 &H10 SMAuthentication(Algorithm@, Le=0)
Declare Command &HC0 &H12 EndEncryption()
Declare Command &HC0 &H14 Echo(S$)
Declare Command &HC0 &H16 AssignNAD()
Declare Command &HC0 &H1A START_TRANSACTION()
Declare Command &HC0 &H1C COMMIT_TRANSACTION()
Declare Command &HC0 &H1E ABORT_TRANSACTION()

Rem  Commands for BasicCards with 24-bit addresses

Declare Command &HC0 &H02 Eeprom24Size(Lc=0, Start As String*3, Length As String*3)
Declare Command &HC0 &H04 ClearEeprom24(Start As String*3, Length As String*3, Disable Le)
Declare Command &HC0 &H08 ReadEeprom24(Lc=3, ReadOnly Address As String*3, Data$)
Declare Command &HC0 &H0A Eeprom24CRC(Lc=6, ReadOnly Address As String*3, ReadOnly Length As String*3, CRC%, Le=8)
Declare Command &HC0 &H0A Eeprom24CRC32(Lc=6, ReadOnly Address As String*3, ReadOnly Length As String*3, CRC&, Le=10)

Rem BasicCard operating system errors

Const swCommandOK              = &H9000
Const swRetriesRemaining       = &H63C0
Const swEepromWriteError       = &H6581
Const swBadEepromHeap          = &H6582
Const swBadFileChain           = &H6583
Const swKeyNotFound            = &H6611
Const swPolyNotFound           = &H6612
Const swKeyTooShort            = &H6613
Const swKeyDisabled            = &H6614
Const swUnknownAlgorithm       = &H6615
Const swAlreadyEncrypting      = &H66C0
Const swNotEncrypting          = &H66C1
Const swBadCommandCRC          = &H66C2
Const swDesCheckError          = &H66C3
Const swCoprocessorError       = &H66C4
Const swAesCheckError          = &H66C5
Const swBadSignature           = &H66C6
Const swBadAuthenticate        = &H66C7
Const swLcLeError              = &H6700
Const swCommandTooLong         = &H6781
Const swResponseTooLong        = &H6782
Const swInvalidState           = &H6985
Const swCardUnconfigured       = &H6986
Const swNewStateError          = &H6987
Const swSMError                = &H6988
Const swP1P2Error              = &H6A00
Const swOutsideEeprom          = &H6A02
Const swBadCommandData         = &H6A80
Const swDataNotFound           = &H6A88
Const swTransactionActive      = &H6A90
Const swTransactionNotActive   = &H6A91
Const swINSNotFound            = &H6D00
Const swCLANotFound            = &H6E00
Const swInternalError          = &H6F00

Rem SW1=&H61 is Le warning:

Const sw1LeWarning             = &H61

Rem SW1=&H6C is La warning (T=0 protocol only):

Const sw1LaWarning             = &H6C

Rem P-Code interpreter errors (SW1=&H64, SW2=P-Code error)

Const sw1PCodeError            = &H64

Const pcStackOverflow          = &H01
Const pcDivideByZero           = &H02
Const pcNotImplemented         = &H03
Const pcBadRamHeap             = &H04
Const pcBadEepromHeap          = &H05
Const pcReturnWithoutGoSub     = &H06
Const pcBadSubscript           = &H07
Const pcBadBounds              = &H08
Const pcInvalidReal            = &H09
Const pcOverflow               = &H0A
Const pcNegativeSqrt           = &H0B
Const pcDimensionError         = &H0C
Const pcBadStringCall          = &H0D
Const pcOutOfMemory            = &H0E
Const pcArrayNotDynamic        = &H0F
Const pcArrayTooBig            = &H10
Const pcDeletedArray           = &H11
Const pcPCodeDisabled          = &H12
Const pcBadSystemCall          = &H13
Const pcBadKey                 = &H14
Const pcBadLibraryCall         = &H15
Const pcStackUnderflow         = &H16
Const pcInvalidAddress         = &H17
Const pcTransactionTooBig      = &H18
Const pcTransactionActive      = &H19

Rem Error codes generated by the Terminal

Const swNoCardReader           = &H6790
Const swCardReaderError        = &H6791
Const swNoCardInReader         = &H6792
Const swCardPulled             = &H6793
Const swT1Error                = &H6794
Const swCardError              = &H6795
Const swCardNotReset           = &H6796
Const swKeyNotLoaded           = &H6797
Const swPolyNotLoaded          = &H6798
Const swBadResponseCRC         = &H6799
Const swCardTimedOut           = &H679A
Const swTermOutOfMemory        = &H679B
Const swBadDesResponse         = &H679C
Const swInvalidComPort         = &H679D
Const swNoPcscDriver           = &H679F
Const swPcscReaderBusy         = &H67A0
Const swPcscError              = &H67A1
Const swComPortBusy            = &H67A2
Const swBadATR                 = &H67A3
Const swT0Error                = &H67A4
Const swPTSError               = &H67A7
Const swDataOverrun            = &H67A8
Const swBadAesResponse         = &H67A9
Const swZCMDCardObsolete       = &H67AA
Const swZCMDTermObsolete       = &H67AB
Const swCommandTooShort        = &H67C0
Const swCommandFormat          = &H67C1
Const swResponseTooShort       = &H67C2
Const swUnexpectedResponse     = &H67C3
Const swInvalidSetState        = &H67C4
Const swTerminalProgramRunning = &H67C5
Const swAppLoadFailure         = &H67C6
Const swReservedINS            = &H6D80
Const swReservedCLA            = &H6E80

Rem  MuliApplication BasicCard errors
Rem  (corresponding to Component Library errors in COMPONNT.DEF)

Const swBadComponentName         = &H69C0
Const swComponentNotFound        = &H69C1
Const swAccessDenied             = &H69C2
Const swComponentAlreadyExists   = &H69C3
Const swBadComponentChain        = &H69C4
Const swNameTooLong              = &H69C5
Const swOutOfMemory              = &H69C6
Const swInvalidACR               = &H69C7
Const swBadComponentType         = &H69C8
'Const swKeyNotFound              = &H69CC swKeyNotFound already exists
Const swKeyUsage                 = &H69CD
Const swKeyAlgorithm             = &H69CE
'Const swKeyDisabled              = &H69CF swKeyDisabled already exists
Const swTooManyTempFlags         = &H69D0
Const swExecutableAcrDenied      = &H69D1
Const swApplicationNotFound      = &H69D2
Const swACRDepth                 = &H69D3
Const swBadComponentAttr         = &H69D4
Const swBadComponentData         = &H69D5
Const swBadAppFile               = &H69D6
Const swLoadSequenceActive       = &H69D7
Const swLoadSequenceNotActive    = &H69D8
Const swLoadSequencePhase        = &H69D9
'Const swKeyTooShort              = &H69DA swKeyTooShort already exists
'Const swUnknownAlgorithm         = &H69DB swUnknownAlgorithm already exists
Const swBadEaxTag                = &H69DC
Const swSecureTransportActive    = &H69DD
Const swSecureTransportInactive  = &H69DE
Const swComponentReferenced      = &H69DF
Const swFileNotContiguous        = &H69E0
Const swAppFileOpen              = &H69E1

#IfDef TerminalProgram

Rem  AutoEncryption handles StartEncryption for the different card types.
Rem  To use:
Rem          Call AutoEncryption (KeyNum@, KeyName$)
Rem          Call CheckSW1SW2()
Rem
Rem  KeyNum@ is the key number, for all card types. Encrypting for the
Rem  MultiApplication BasicCard also requires the key's path name, in KeyName$.

#Include MISC.DEF
#Include COMPONNT.DEF

Sub AutoEncryption (KeyNum@, KeyName$)

  Private TryAES : TryAES = (Len (Key(KeyNum@)) >= 16)
  If TryAES Then
    Call ProEncryption (P2=KeyNum@, Rnd, Rnd)
    If SW1SW2 = swLcLeError Then Call StartEncryption (P2=KeyNum@, Rnd)
  Else
    Call StartEncryption (P2=KeyNum@, Rnd)
  End If

  Select Case SW1SW2

    Case swUnknownAlgorithm ' Compact BasicCard doesn't support P1=0
      Call StartEncryption (P1=&H12, P2=KeyNum@, Rnd)

    Case swBadComponentType ' MultiApplication BasicCard
      Private CID : CID = FindComponent (ctKey, KeyName$)
      Call AddIndexedKey (CID, Key(KeyNum@))
      If TryAES Then
        Call SMEncryption (P1P2=CID, 0, Rnd, Rnd)
      Else
        Call SMEncryption (P1P2=CID, Lc=5, 0, Rnd, 0)
      End If

  End Select

End Sub

Rem  Sub SMEncryptionByCID (KeyCID%, KeyVal$, Algorithm@)
Rem  Sub SMEncryptionByName (KeyName$, KeyVal$, Algorithm@)
Rem
Rem  These procedures activate encryption in the MultiApplication BasicCard.
Rem  SMEncryptionByName is simpler; SMEncryptionByCID is faster, saving
Rem  a call to FincComponent.

Sub SMEncryptionByCID (KeyCID%, KeyVal$, Algorithm@)

  Rem  Tell the Terminal program interpreter the value of the key
  Call AddIndexedKey (KeyCID%, KeyVal$)

  If Algorithm@ < AlgOmacAes128 Then

    Rem  Encryption algorithm - initialisation data required

    If Algorithm@ <= AlgTripleDesCrc Then ' Four-byte initialisation data
      Call SMEncryption (P1P2=KeyCID%, Lc=5, Algorithm@, Rnd, 0)
    Else                                 ' Eight-byte initialisation data
      Call SMEncryption (P1P2=KeyCID%, Algorithm@, Rnd, Rnd)
    End If

  Else

    Rem  Authentication algorithm - no initialisation data required
    Call SMEncryption (P1P2=KeyCID%, Lc=1, Algorithm@, 0, 0)

  End If

End Sub

Sub SMEncryptionByName (KeyName$, KeyVal$, Algorithm@)
  Private CID : CID = FindComponent (ctKey, KeyName$)
  If SW1SW2 = swCommandOK Then _
    Call SMEncryptionByCID (CID, KeyVal$, Algorithm@)
End Sub

#EndIf ' TerminalProgram

#EndIf ' CommandsDefIncluded
