Rem BasicCard TLV Library
Rem ------------------------------------------------------------------
Rem Copyright (C) 2008 ZeitControl GmbH
Rem You have a royalty-free right to use, modify, reproduce and 
Rem distribute the Sample Application Files (and/or any modified 
Rem version) in any way you find useful, provided that you agree 
Rem that ZeitControl GmbH has no warranty, obligations or liability
Rem for any Sample Application Files.
Rem ------------------------------------------------------------------

#IfNotDef TlvDefIncluded ' Prevent multiple inclusion
Const TlvDefIncluded = True

Type TlvPointer
   Start as Integer
   Tag as Integer
   Length as Integer
   ' Info contains following information:
   '     Bit 0 to 3 Offset of Value Field
   '     Bit 7 to 6 Tag Class
   '     Bit 5 constructed indicator - 1 constructed, 0 primitive
   '     Bit 4 valid indicator - 1 valid, 0 invalid
   Info as Byte
End Type

' Errors are reported in LibError variable
#ifDef EnhancedBasicCard
#IfNotDef LibErrorDeclared
Const LibErrorDeclared = True
Public LibError As Integer
#EndIf
#EndIf


' Tlv Error codes
Const TlvEInvalid=&H4E01 ' Invalid or unsupported TLV object
Const TlvENotConstructed=&H4E02 ' The parent object is a primitive TLV which does not contain childs

' Moves the Ptr to next object if exists, reading tag and length too.
' If no next object exists Ptr.Info is set to 0.
' Data is expected to hold the TLV object(s) as string on input.
' If EndPos is < 0 (-1) the end position is defined by data length,
' otherwise this specifies then end position for searching objects.
' This means objects are valid up to Data(EndPos-1).
' 0 bytes within Data beginning at current start position are regarded as
' padding and are skipped.
' To read first object initialize Ptr.Start to start position in string (e.g. 1)
' before calling this Sub.
Declare Sub TlvNextObject(ByRef Ptr as TlvPointer, ReadOnly Data as String, ByVal EndPos as Integer)

' Find next child tlv object within (constructed) Parent and put the result into Child.
' If no next child exists Child.Info is set to 0.
' Data is expected to hold the TLV object(s) as string on input.
' If on input Child.Info = 0 then first child of parent is searched for.
' Otherwise Child is expected to contain preceeding child object on input.
' 0 bytes at end of preceeding child are regarded as padding and are skipped.
Declare Sub TlvNextChild(ReadOnly Parent as TlvPointer, ByRef Child as TlvPointer, ReadOnly Data as String)

' Find Nth (>=1) next child tlv object within (constructed) Parent which matches specified Tag and put the result into Child.
' If on input Child.Info = 0 then search begins at first child of parent, otherwise behind current child.
' If no matching child exists Child.Info is set to 0.
' Otherwise Child is expected to contain preceeding child object on input.
' Data is expected to hold the TLV object(s) as string on input.
' 0 bytes at start of parent value are regarded as padding and are skipped.
Declare Sub TlvMatchingChild(ReadOnly Parent as TlvPointer, ByRef Child as TlvPointer, ReadOnly Data as String, _
                             ByVal Tag as Integer, ByVal N as Integer)

' Read tag length and info from Data string and put this into Ptr.
' Data is expected to hold the TLV object(s) as string on input.
' Ptr.Start is expected to be valid and point to start position
' of desired TLV object within Data string, e.g. 1.
Declare Sub TlvReadTagLength(ByRef Ptr as TlvPointer, ReadOnly Data as String)

' Get the value pointed to by Ptr.
' Data is expected to hold the TLV object(s) as string on input.
' If the pointer Ptr is invalid an empty string is returned.
Declare Function TlvGetValue(ReadOnly Ptr as TlvPointer, ReadOnly Data as String) as String

' Create a TLV object with specified content
Declare Function TlvCreateObject(ByVal Tag as Integer, ReadOnly Value as String) as String

Function TlvGetValue(ReadOnly Ptr as TlvPointer, ReadOnly Data as String) as String
   Private Pos as Integer
   if (Ptr.Info AND &H10)<>0 then 
      Pos=Ptr.Start + (Ptr.Info AND &H0F) 
      TlvGetValue=Mid$(Data, Pos, Ptr.Length)
   end if
End Function

Sub TlvMatchingChild(ReadOnly Parent as TlvPointer, ByRef Child as TlvPointer, ReadOnly Data as String, _
                          ByVal Tag as Integer, ByVal N as Integer)
   if N<1 then LibError=TlvEInvalid : exit sub
   do 
      Call TlvNextChild(Parent, Child, Data)
      if Tag=Child.Tag then
         N=N-1
      end if
   loop while (Child.Info<>0) AND (N>0)
End Sub

Sub TlvNextChild(ReadOnly Parent as TlvPointer, ByRef Child as TlvPointer, ReadOnly Data as String)
   if (Parent.Info AND &H10) = 0 then LibError=TlvEInvalid : exit sub
   if (Parent.Info AND &H20) = 0 then LibError=TlvENotConstructed : exit sub
   Private EndPos as Integer
   EndPos=Parent.Start + (Parent.Info AND &H0F) + Parent.Length - 1
   if Child.Info=0 then
      Child.Start=Parent.Start + (Parent.Info AND &H0F)
      Child.Info=&H10
      Child.Length=0
   end if
   if (Child.Info AND &H10) = 0 then exit sub
   Call TlvNextObject(Child, Data, EndPos)
End Sub

Sub TlvNextObject(ByRef Ptr as TlvPointer, ReadOnly Data as String, ByVal EndPos as Integer)
   if EndPos<0 then EndPos=Len(Data)+1
   if ((EndPos-1)>Len(Data)) OR ((Ptr.Info AND &H10)=0) then LibError=TlvEInvalid : exit sub
   if Ptr.Start=0 then Ptr.Start=1 ' fix not initialized start value
   Ptr.Start=Ptr.Start + (Ptr.Info AND &H0F) + Ptr.Length
   while (Ptr.Start<EndPos) AND (0=Asc(Data(Ptr.Start)))
      Ptr.Start=Ptr.Start+1
   wend
   if Ptr.Start>=EndPos then
      Ptr.Info=0
   else
      Call TlvReadTagLength(Ptr, Data)
   end if
End Sub

Const TlvLength1=Chr$(&H81)
Const TlvLength2=Chr$(&H82)

Function TlvCreateObject(ByVal Tag as Integer, ReadOnly Value as String) as String
   Private TagB1 as Byte at Tag
   Private TagB2 as Byte at Tag+1
   Private TagS as String*2 at Tag
   Private TagS1 as String*1 at Tag
   Private TagS2 as String*1 at Tag+1
   TlvCreateObject=""
   if TagB1<>0 then TlvCreateObject=TagS1
   TlvCreateObject=TlvCreateObject+TagS2
   ' using ByVal Tag as temporary variable
   Tag=Len(Value)
   if TagB1<>0 then
      TlvCreateObject=TlvCreateObject+TlvLength2+TagS
   else : if TagB2>&H7F then
      TlvCreateObject=TlvCreateObject+TlvLength1+TagS2
   else
      TlvCreateObject=TlvCreateObject+TagS2
   end if : end if
   TlvCreateObject=TlvCreateObject+Value
End Function

Sub TlvReadTagLength(ByRef Ptr as TlvPointer, ReadOnly Data as String)
   Private Pos as Integer
   if Ptr.Start=0 then Ptr.Start=1 ' Fix Uninitialized start value
   Pos=Ptr.Start
   GoSub TlvReadTagLengthCheckLen
   ' First byte is always Tag with class and constructed/primitive flag
   Ptr.Tag=Asc(Data(Pos))
   Ptr.Info=Ptr.Tag AND &HE0
   ' Next position
   Pos=Pos+1
   GoSub TlvReadTagLengthCheckLen
   if (Ptr.Tag AND &H1F)=&H1F then
      ' xxx11111 in first byte indicate second tag byte
      ' take care of values with top bit set 
      ' 16 bit signed integer will overflow otherwise
      if (Ptr.Tag AND &H80) <> 0 then Ptr.Tag=Ptr.Tag OR &HFF00
      ' add second tag byte
      Ptr.Tag=Ptr.Tag*256 + Asc(Data(Pos))
      ' top bit in second tag byte will indicate more
      ' tag bytes. this is not supported
      if (Ptr.Tag AND &H80) > 0 then goto TlvReadTagLengthFaultExit
      ' Next position
      Pos=Pos+1
      GoSub TlvReadTagLengthCheckLen
   end if
   ' Parse length element
   Ptr.Length=Asc(Data(Pos))
   select case Ptr.Length
      case &H81
         ' next byte length
         Pos=Pos+1
         GoSub TlvReadTagLengthCheckLen
         Ptr.Length=Asc(Data(Pos))
         exit case
      case &H82
         ' next 2 byte length
         Pos=Pos+2
         GoSub TlvReadTagLengthCheckLen
         Ptr.Length=Asc(Data(Pos-1))
         ' Length >= 2^15 not supported
         if (Ptr.Length AND &HC0) > 0 then goto TlvReadTagLengthFaultExit
         Ptr.Length=Ptr.Length * 256 + Asc(Data(Pos))
         exit case
      case &H83, &H84
         ' 3, 4, or 5 byte length not supported
         goto TlvReadTagLengthFaultExit
   end select
   ' Next position
   Pos=Pos+1
   Ptr.Info = Ptr.Info + &H10 + (Pos - Ptr.Start)
   Pos=Pos+Ptr.Length-1
   GoSub TlvReadTagLengthCheckLen
   exit sub
   ' For code size optimization we use gosub to check remaining length and goto to exit sub
TlvReadTagLengthCheckLen:
   if Pos>Len(Data) then 
TlvReadTagLengthFaultExit:
      Ptr.Info=0 : LibError=TlvEInvalid : exit sub
   end if
   return
End sub

#EndIf ' TlvDefIncluded